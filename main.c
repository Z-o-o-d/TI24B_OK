// /*
//  * @Description: 
//  * @Author: Howard
//  * @Date: 2024-07-30 10:24:03
//  * @LastEditTime: 2024-07-31 03:15:54
//  * @LastEditors: Howard
//  */
#include <msp430.h> 
#include <stdint.h>
#include <stdlib.h>
#include "stdio.h"

#include <math.h>
#include <stdarg.h>
#include "lib/MSP430F5xx_6xx/driverlib.h"
#include "lib/DSPLib_1_30_00_02/include/DSPLib.h"

#define MCLK_IN_HZ      10000000
#define delay_us(x)     __delay_cycles((MCLK_IN_HZ/1000000*(x)))
#define delay_ms(x)     __delay_cycles((MCLK_IN_HZ/1000*(x)))
#define FFT_Dot             256
#define SAMP_Dot             400

#define FS                  2000
#define PI                  3.1415926536
#define TIMER_PERIOD 125




const unsigned char F6x8[][6] =
{
0x00, 0x00, 0x00, 0x00, 0x00, 0x00,// sp
0x00, 0x00, 0x00, 0x2f, 0x00, 0x00,// !
0x00, 0x00, 0x07, 0x00, 0x07, 0x00,// "
0x00, 0x14, 0x7f, 0x14, 0x7f, 0x14,// #
0x00, 0x24, 0x2a, 0x7f, 0x2a, 0x12,// $
0x00, 0x62, 0x64, 0x08, 0x13, 0x23,// %
0x00, 0x36, 0x49, 0x55, 0x22, 0x50,// &
0x00, 0x00, 0x05, 0x03, 0x00, 0x00,// '
0x00, 0x00, 0x1c, 0x22, 0x41, 0x00,// (
0x00, 0x00, 0x41, 0x22, 0x1c, 0x00,// )
0x00, 0x14, 0x08, 0x3E, 0x08, 0x14,// *
0x00, 0x08, 0x08, 0x3E, 0x08, 0x08,// +
0x00, 0x00, 0x00, 0xA0, 0x60, 0x00,// ,
0x00, 0x08, 0x08, 0x08, 0x08, 0x08,// -
0x00, 0x00, 0x60, 0x60, 0x00, 0x00,// .
0x00, 0x20, 0x10, 0x08, 0x04, 0x02,// /
0x00, 0x3E, 0x51, 0x49, 0x45, 0x3E,// 0
0x00, 0x00, 0x42, 0x7F, 0x40, 0x00,// 1
0x00, 0x42, 0x61, 0x51, 0x49, 0x46,// 2
0x00, 0x21, 0x41, 0x45, 0x4B, 0x31,// 3
0x00, 0x18, 0x14, 0x12, 0x7F, 0x10,// 4
0x00, 0x27, 0x45, 0x45, 0x45, 0x39,// 5
0x00, 0x3C, 0x4A, 0x49, 0x49, 0x30,// 6
0x00, 0x01, 0x71, 0x09, 0x05, 0x03,// 7
0x00, 0x36, 0x49, 0x49, 0x49, 0x36,// 8
0x00, 0x06, 0x49, 0x49, 0x29, 0x1E,// 9
0x00, 0x00, 0x36, 0x36, 0x00, 0x00,// :
0x00, 0x00, 0x56, 0x36, 0x00, 0x00,// ;
0x00, 0x08, 0x14, 0x22, 0x41, 0x00,// <
0x00, 0x14, 0x14, 0x14, 0x14, 0x14,// =
0x00, 0x00, 0x41, 0x22, 0x14, 0x08,// >
0x00, 0x02, 0x01, 0x51, 0x09, 0x06,// ?
0x00, 0x32, 0x49, 0x59, 0x51, 0x3E,// @
0x00, 0x7C, 0x12, 0x11, 0x12, 0x7C,// A
0x00, 0x7F, 0x49, 0x49, 0x49, 0x36,// B
0x00, 0x3E, 0x41, 0x41, 0x41, 0x22,// C
0x00, 0x7F, 0x41, 0x41, 0x22, 0x1C,// D
0x00, 0x7F, 0x49, 0x49, 0x49, 0x41,// E
0x00, 0x7F, 0x09, 0x09, 0x09, 0x01,// F
0x00, 0x3E, 0x41, 0x49, 0x49, 0x7A,// G
0x00, 0x7F, 0x08, 0x08, 0x08, 0x7F,// H
0x00, 0x00, 0x41, 0x7F, 0x41, 0x00,// I
0x00, 0x20, 0x40, 0x41, 0x3F, 0x01,// J
0x00, 0x7F, 0x08, 0x14, 0x22, 0x41,// K
0x00, 0x7F, 0x40, 0x40, 0x40, 0x40,// L
0x00, 0x7F, 0x02, 0x0C, 0x02, 0x7F,// M
0x00, 0x7F, 0x04, 0x08, 0x10, 0x7F,// N
0x00, 0x3E, 0x41, 0x41, 0x41, 0x3E,// O
0x00, 0x7F, 0x09, 0x09, 0x09, 0x06,// P
0x00, 0x3E, 0x41, 0x51, 0x21, 0x5E,// Q
0x00, 0x7F, 0x09, 0x19, 0x29, 0x46,// R
0x00, 0x46, 0x49, 0x49, 0x49, 0x31,// S
0x00, 0x01, 0x01, 0x7F, 0x01, 0x01,// T
0x00, 0x3F, 0x40, 0x40, 0x40, 0x3F,// U
0x00, 0x1F, 0x20, 0x40, 0x20, 0x1F,// V
0x00, 0x3F, 0x40, 0x38, 0x40, 0x3F,// W
0x00, 0x63, 0x14, 0x08, 0x14, 0x63,// X
0x00, 0x07, 0x08, 0x70, 0x08, 0x07,// Y
0x00, 0x61, 0x51, 0x49, 0x45, 0x43,// Z
0x00, 0x00, 0x7F, 0x41, 0x41, 0x00,// [
0x00, 0x55, 0x2A, 0x55, 0x2A, 0x55,// 55
0x00, 0x00, 0x41, 0x41, 0x7F, 0x00,// ]
0x00, 0x04, 0x02, 0x01, 0x02, 0x04,// ^
0x00, 0x40, 0x40, 0x40, 0x40, 0x40,// _
0x00, 0x00, 0x01, 0x02, 0x04, 0x00,// '
0x00, 0x20, 0x54, 0x54, 0x54, 0x78,// a
0x00, 0x7F, 0x48, 0x44, 0x44, 0x38,// b
0x00, 0x38, 0x44, 0x44, 0x44, 0x20,// c
0x00, 0x38, 0x44, 0x44, 0x48, 0x7F,// d
0x00, 0x38, 0x54, 0x54, 0x54, 0x18,// e
0x00, 0x08, 0x7E, 0x09, 0x01, 0x02,// f
0x00, 0x18, 0xA4, 0xA4, 0xA4, 0x7C,// g
0x00, 0x7F, 0x08, 0x04, 0x04, 0x78,// h
0x00, 0x00, 0x44, 0x7D, 0x40, 0x00,// i
0x00, 0x40, 0x80, 0x84, 0x7D, 0x00,// j
0x00, 0x7F, 0x10, 0x28, 0x44, 0x00,// k
0x00, 0x00, 0x41, 0x7F, 0x40, 0x00,// l
0x00, 0x7C, 0x04, 0x18, 0x04, 0x78,// m
0x00, 0x7C, 0x08, 0x04, 0x04, 0x78,// n
0x00, 0x38, 0x44, 0x44, 0x44, 0x38,// o
0x00, 0xFC, 0x24, 0x24, 0x24, 0x18,// p
0x00, 0x18, 0x24, 0x24, 0x18, 0xFC,// q
0x00, 0x7C, 0x08, 0x04, 0x04, 0x08,// r
0x00, 0x48, 0x54, 0x54, 0x54, 0x20,// s
0x00, 0x04, 0x3F, 0x44, 0x40, 0x20,// t
0x00, 0x3C, 0x40, 0x40, 0x20, 0x7C,// u
0x00, 0x1C, 0x20, 0x40, 0x20, 0x1C,// v
0x00, 0x3C, 0x40, 0x30, 0x40, 0x3C,// w
0x00, 0x44, 0x28, 0x10, 0x28, 0x44,// x
0x00, 0x1C, 0xA0, 0xA0, 0xA0, 0x7C,// y
0x00, 0x44, 0x64, 0x54, 0x4C, 0x44,// z
0x14, 0x14, 0x14, 0x14, 0x14, 0x14,// horiz lines
};
/****************************************8*16 dot matrix************************************/
const unsigned char F8X16[]=
{
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,// 0
  0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x33,0x30,0x00,0x00,0x00,//! 1
  0x00,0x10,0x0C,0x06,0x10,0x0C,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//" 2
  0x40,0xC0,0x78,0x40,0xC0,0x78,0x40,0x00,0x04,0x3F,0x04,0x04,0x3F,0x04,0x04,0x00,//# 3
  0x00,0x70,0x88,0xFC,0x08,0x30,0x00,0x00,0x00,0x18,0x20,0xFF,0x21,0x1E,0x00,0x00,//$ 4
  0xF0,0x08,0xF0,0x00,0xE0,0x18,0x00,0x00,0x00,0x21,0x1C,0x03,0x1E,0x21,0x1E,0x00,//% 5
  0x00,0xF0,0x08,0x88,0x70,0x00,0x00,0x00,0x1E,0x21,0x23,0x24,0x19,0x27,0x21,0x10,//& 6
  0x10,0x16,0x0E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//' 7
  0x00,0x00,0x00,0xE0,0x18,0x04,0x02,0x00,0x00,0x00,0x00,0x07,0x18,0x20,0x40,0x00,//( 8
  0x00,0x02,0x04,0x18,0xE0,0x00,0x00,0x00,0x00,0x40,0x20,0x18,0x07,0x00,0x00,0x00,//) 9
  0x40,0x40,0x80,0xF0,0x80,0x40,0x40,0x00,0x02,0x02,0x01,0x0F,0x01,0x02,0x02,0x00,//* 10
  0x00,0x00,0x00,0xF0,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x1F,0x01,0x01,0x01,0x00,//+ 11
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xB0,0x70,0x00,0x00,0x00,0x00,0x00,//, 12
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,//- 13
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,0x00,0x00,//. 14
  0x00,0x00,0x00,0x00,0x80,0x60,0x18,0x04,0x00,0x60,0x18,0x06,0x01,0x00,0x00,0x00,/// 15
  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x0F,0x10,0x20,0x20,0x10,0x0F,0x00,//0 16
  0x00,0x10,0x10,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//1 17
  0x00,0x70,0x08,0x08,0x08,0x88,0x70,0x00,0x00,0x30,0x28,0x24,0x22,0x21,0x30,0x00,//2 18
  0x00,0x30,0x08,0x88,0x88,0x48,0x30,0x00,0x00,0x18,0x20,0x20,0x20,0x11,0x0E,0x00,//3 19
  0x00,0x00,0xC0,0x20,0x10,0xF8,0x00,0x00,0x00,0x07,0x04,0x24,0x24,0x3F,0x24,0x00,//4 20
  0x00,0xF8,0x08,0x88,0x88,0x08,0x08,0x00,0x00,0x19,0x21,0x20,0x20,0x11,0x0E,0x00,//5 21
  0x00,0xE0,0x10,0x88,0x88,0x18,0x00,0x00,0x00,0x0F,0x11,0x20,0x20,0x11,0x0E,0x00,//6 22
  0x00,0x38,0x08,0x08,0xC8,0x38,0x08,0x00,0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00,//7 23
  0x00,0x70,0x88,0x08,0x08,0x88,0x70,0x00,0x00,0x1C,0x22,0x21,0x21,0x22,0x1C,0x00,//8 24
  0x00,0xE0,0x10,0x08,0x08,0x10,0xE0,0x00,0x00,0x00,0x31,0x22,0x22,0x11,0x0F,0x00,//9 25
  0x00,0x00,0x00,0xC0,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00,0x00,0x00,//: 26
  0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x60,0x00,0x00,0x00,0x00,//; 27
  0x00,0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00,0x01,0x02,0x04,0x08,0x10,0x20,0x00,//< 28
  0x40,0x40,0x40,0x40,0x40,0x40,0x40,0x00,0x04,0x04,0x04,0x04,0x04,0x04,0x04,0x00,//= 29
  0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x01,0x00,//> 30
  0x00,0x70,0x48,0x08,0x08,0x08,0xF0,0x00,0x00,0x00,0x00,0x30,0x36,0x01,0x00,0x00,//? 31
  0xC0,0x30,0xC8,0x28,0xE8,0x10,0xE0,0x00,0x07,0x18,0x27,0x24,0x23,0x14,0x0B,0x00,//@ 32
  0x00,0x00,0xC0,0x38,0xE0,0x00,0x00,0x00,0x20,0x3C,0x23,0x02,0x02,0x27,0x38,0x20,//A 33
  0x08,0xF8,0x88,0x88,0x88,0x70,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x11,0x0E,0x00,//B 34
  0xC0,0x30,0x08,0x08,0x08,0x08,0x38,0x00,0x07,0x18,0x20,0x20,0x20,0x10,0x08,0x00,//C 35
  0x08,0xF8,0x08,0x08,0x08,0x10,0xE0,0x00,0x20,0x3F,0x20,0x20,0x20,0x10,0x0F,0x00,//D 36
  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x20,0x23,0x20,0x18,0x00,//E 37
  0x08,0xF8,0x88,0x88,0xE8,0x08,0x10,0x00,0x20,0x3F,0x20,0x00,0x03,0x00,0x00,0x00,//F 38
  0xC0,0x30,0x08,0x08,0x08,0x38,0x00,0x00,0x07,0x18,0x20,0x20,0x22,0x1E,0x02,0x00,//G 39
  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x20,0x3F,0x21,0x01,0x01,0x21,0x3F,0x20,//H 40
  0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//I 41
  0x00,0x00,0x08,0x08,0xF8,0x08,0x08,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,0x00,//J 42
  0x08,0xF8,0x88,0xC0,0x28,0x18,0x08,0x00,0x20,0x3F,0x20,0x01,0x26,0x38,0x20,0x00,//K 43
  0x08,0xF8,0x08,0x00,0x00,0x00,0x00,0x00,0x20,0x3F,0x20,0x20,0x20,0x20,0x30,0x00,//L 44
  0x08,0xF8,0xF8,0x00,0xF8,0xF8,0x08,0x00,0x20,0x3F,0x00,0x3F,0x00,0x3F,0x20,0x00,//M 45
  0x08,0xF8,0x30,0xC0,0x00,0x08,0xF8,0x08,0x20,0x3F,0x20,0x00,0x07,0x18,0x3F,0x00,//N 46
  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x10,0x20,0x20,0x20,0x10,0x0F,0x00,//O 47
  0x08,0xF8,0x08,0x08,0x08,0x08,0xF0,0x00,0x20,0x3F,0x21,0x01,0x01,0x01,0x00,0x00,//P 48
  0xE0,0x10,0x08,0x08,0x08,0x10,0xE0,0x00,0x0F,0x18,0x24,0x24,0x38,0x50,0x4F,0x00,//Q 49
  0x08,0xF8,0x88,0x88,0x88,0x88,0x70,0x00,0x20,0x3F,0x20,0x00,0x03,0x0C,0x30,0x20,//R 50
  0x00,0x70,0x88,0x08,0x08,0x08,0x38,0x00,0x00,0x38,0x20,0x21,0x21,0x22,0x1C,0x00,//S 51
  0x18,0x08,0x08,0xF8,0x08,0x08,0x18,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//T 52
  0x08,0xF8,0x08,0x00,0x00,0x08,0xF8,0x08,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//U 53
  0x08,0x78,0x88,0x00,0x00,0xC8,0x38,0x08,0x00,0x00,0x07,0x38,0x0E,0x01,0x00,0x00,//V 54
  0xF8,0x08,0x00,0xF8,0x00,0x08,0xF8,0x00,0x03,0x3C,0x07,0x00,0x07,0x3C,0x03,0x00,//W 55
  0x08,0x18,0x68,0x80,0x80,0x68,0x18,0x08,0x20,0x30,0x2C,0x03,0x03,0x2C,0x30,0x20,//X 56
  0x08,0x38,0xC8,0x00,0xC8,0x38,0x08,0x00,0x00,0x00,0x20,0x3F,0x20,0x00,0x00,0x00,//Y 57
  0x10,0x08,0x08,0x08,0xC8,0x38,0x08,0x00,0x20,0x38,0x26,0x21,0x20,0x20,0x18,0x00,//Z 58
  0x00,0x00,0x00,0xFE,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x7F,0x40,0x40,0x40,0x00,//[ 59
  0x00,0x0C,0x30,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x06,0x38,0xC0,0x00,//\ 60
  0x00,0x02,0x02,0x02,0xFE,0x00,0x00,0x00,0x00,0x40,0x40,0x40,0x7F,0x00,0x00,0x00,//] 61
  0x00,0x00,0x04,0x02,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//^ 62
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x80,//_ 63
  0x00,0x02,0x02,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//` 64
  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x19,0x24,0x22,0x22,0x22,0x3F,0x20,//a 65
  0x08,0xF8,0x00,0x80,0x80,0x00,0x00,0x00,0x00,0x3F,0x11,0x20,0x20,0x11,0x0E,0x00,//b 66
  0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x0E,0x11,0x20,0x20,0x20,0x11,0x00,//c 67
  0x00,0x00,0x00,0x80,0x80,0x88,0xF8,0x00,0x00,0x0E,0x11,0x20,0x20,0x10,0x3F,0x20,//d 68
  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x22,0x22,0x22,0x22,0x13,0x00,//e 69
  0x00,0x80,0x80,0xF0,0x88,0x88,0x88,0x18,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//f 70
  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x6B,0x94,0x94,0x94,0x93,0x60,0x00,//g 71
  0x08,0xF8,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//h 72
  0x00,0x80,0x98,0x98,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//i 73
  0x00,0x00,0x00,0x80,0x98,0x98,0x00,0x00,0x00,0xC0,0x80,0x80,0x80,0x7F,0x00,0x00,//j 74
  0x08,0xF8,0x00,0x00,0x80,0x80,0x80,0x00,0x20,0x3F,0x24,0x02,0x2D,0x30,0x20,0x00,//k 75
  0x00,0x08,0x08,0xF8,0x00,0x00,0x00,0x00,0x00,0x20,0x20,0x3F,0x20,0x20,0x00,0x00,//l 76
  0x80,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x20,0x3F,0x20,0x00,0x3F,0x20,0x00,0x3F,//m 77
  0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x3F,0x21,0x00,0x00,0x20,0x3F,0x20,//n 78
  0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x1F,0x20,0x20,0x20,0x20,0x1F,0x00,//o 79
  0x80,0x80,0x00,0x80,0x80,0x00,0x00,0x00,0x80,0xFF,0xA1,0x20,0x20,0x11,0x0E,0x00,//p 80
  0x00,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x0E,0x11,0x20,0x20,0xA0,0xFF,0x80,//q 81
  0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x20,0x20,0x3F,0x21,0x20,0x00,0x01,0x00,//r 82
  0x00,0x00,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x33,0x24,0x24,0x24,0x24,0x19,0x00,//s 83
  0x00,0x80,0x80,0xE0,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x1F,0x20,0x20,0x00,0x00,//t 84
  0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x00,0x00,0x1F,0x20,0x20,0x20,0x10,0x3F,0x20,//u 85
  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x01,0x0E,0x30,0x08,0x06,0x01,0x00,//v 86
  0x80,0x80,0x00,0x80,0x00,0x80,0x80,0x80,0x0F,0x30,0x0C,0x03,0x0C,0x30,0x0F,0x00,//w 87
  0x00,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x20,0x31,0x2E,0x0E,0x31,0x20,0x00,//x 88
  0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x81,0x8E,0x70,0x18,0x06,0x01,0x00,//y 89
  0x00,0x80,0x80,0x80,0x80,0x80,0x80,0x00,0x00,0x21,0x30,0x2C,0x22,0x21,0x30,0x00,//z 90
  0x00,0x00,0x00,0x00,0x80,0x7C,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x3F,0x40,0x40,//{ 91
  0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,//| 92
  0x00,0x02,0x02,0x7C,0x80,0x00,0x00,0x00,0x00,0x40,0x40,0x3F,0x00,0x00,0x00,0x00,//} 93
  0x00,0x06,0x01,0x01,0x02,0x02,0x04,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//~ 94
};
char Hzk[][32]={

{0x00,0x00,0xF0,0x10,0x10,0x10,0x10,0xFF,0x10,0x10,0x10,0x10,0xF0,0x00,0x00,0x00},
{0x00,0x00,0x0F,0x04,0x04,0x04,0x04,0xFF,0x04,0x04,0x04,0x04,0x0F,0x00,0x00,0x00},/*"中",0*/

};


#define OLED_MODE 0
#define SIZE 8
#define XLevelL     0x00
#define XLevelH     0x10
#define Max_Column  128
#define Max_Row     64
#define Brightness  0xFF
#define X_WIDTH     128
#define Y_WIDTH     64

#define OLED_SCLK_Clr() P8OUT&=~BIT2  //CLK
#define OLED_SCLK_Set() P8OUT|=BIT2

#define OLED_SDIN_Clr() P8OUT&=~BIT1  //DIN
#define OLED_SDIN_Set() P8OUT|=BIT1

#define OLED_CMD  0
#define OLED_DATA 1

#define u32 unsigned int
#define u16 unsigned short
#define u8 unsigned char


void IIC_Start()
{

    OLED_SCLK_Set();
    OLED_SDIN_Set();
    OLED_SDIN_Clr();
    OLED_SCLK_Clr();
}

/**********************************************
//IIC Stop
**********************************************/
void IIC_Stop()
{
OLED_SCLK_Set() ;
//  OLED_SCLK_Clr();
    OLED_SDIN_Clr();
    OLED_SDIN_Set();

}

void IIC_Wait_Ack()
{
    OLED_SCLK_Set() ;
    OLED_SCLK_Clr();
}
/**********************************************
// IIC Write byte
**********************************************/
void Write_IIC_Byte(unsigned char IIC_Byte)
{
    unsigned char i;
    unsigned char m,da;
    da=IIC_Byte;
    OLED_SCLK_Clr();
    for(i=0;i<8;i++)
    {
            m=da;
        //  OLED_SCLK_Clr();
        m=m&0x80;
        if(m==0x80)
        {OLED_SDIN_Set();}
        else OLED_SDIN_Clr();
            da=da<<1;
        OLED_SCLK_Set();
        OLED_SCLK_Clr();
        }


}
/**********************************************
// IIC Write Command
**********************************************/
void Write_IIC_Command(unsigned char IIC_Command)
{
   IIC_Start();
   Write_IIC_Byte(0x78);            //Slave address,SA0=0
    IIC_Wait_Ack();
   Write_IIC_Byte(0x00);            //write command
    IIC_Wait_Ack();
   Write_IIC_Byte(IIC_Command);
    IIC_Wait_Ack();
   IIC_Stop();
}
/**********************************************
// IIC Write Data
**********************************************/
void Write_IIC_Data(unsigned char IIC_Data)
{
   IIC_Start();
   Write_IIC_Byte(0x78);            //D/C#=0; R/W#=0
    IIC_Wait_Ack();
   Write_IIC_Byte(0x40);            //write data
    IIC_Wait_Ack();
   Write_IIC_Byte(IIC_Data);
    IIC_Wait_Ack();
   IIC_Stop();
}
void OLED_WR_Byte(unsigned dat,unsigned cmd)
{
    if(cmd)
            {

   Write_IIC_Data(dat);

        }
    else {
   Write_IIC_Command(dat);

    }


}


/********************************************
// fill_Picture
********************************************/
void fill_picture(unsigned char fill_Data)
{
    unsigned char m,n;
    for(m=0;m<8;m++)
    {
        OLED_WR_Byte(0xb0+m,0);     //page0-page1
        OLED_WR_Byte(0x00,0);       //low column start address
        OLED_WR_Byte(0x10,0);       //high column start address
        for(n=0;n<128;n++)
            {
                OLED_WR_Byte(fill_Data,1);
            }
    }
}

void Delay_1ms(unsigned int Del_1ms)
{
    unsigned char j;
    while(Del_1ms--)
    {
        for(j=0;j<123;j++);
    }
}


void OLED_Set_Pos(unsigned char x, unsigned char y)
{
    OLED_WR_Byte(0xb0+y,OLED_CMD);
    OLED_WR_Byte(((x&0xf0)>>4)|0x10,OLED_CMD);
    OLED_WR_Byte((x&0x0f),OLED_CMD);
}

void OLED_Display_On(void)
{
    OLED_WR_Byte(0X8D,OLED_CMD); 
    OLED_WR_Byte(0X14,OLED_CMD);  //DCDC ON
    OLED_WR_Byte(0XAF,OLED_CMD);  //DISPLAY ON
}

void OLED_Display_Off(void)
{
    OLED_WR_Byte(0X8D,OLED_CMD);  
    OLED_WR_Byte(0X10,OLED_CMD);  //DCDC OFF
    OLED_WR_Byte(0XAE,OLED_CMD);  //DISPLAY OFF
}

void OLED_Clear(void)
{
    u8 i,n;
    for(i=0;i<8;i++)
    {
        OLED_WR_Byte (0xb0+i,OLED_CMD);
        OLED_WR_Byte (0x00,OLED_CMD);
        OLED_WR_Byte (0x10,OLED_CMD);
        for(n=0;n<128;n++)OLED_WR_Byte(0,OLED_DATA);
    } //¸üÐÂÏÔÊ¾
}
void OLED_On(void)
{
    u8 i,n;
    for(i=0;i<8;i++)
    {
        OLED_WR_Byte (0xb0+i,OLED_CMD);
        OLED_WR_Byte (0x00,OLED_CMD);
        OLED_WR_Byte (0x10,OLED_CMD);
        for(n=0;n<128;n++)OLED_WR_Byte(1,OLED_DATA);
    }
}

//x:0~127
//y:0~63
//size:16/12
void OLED_ShowChar(u8 x,u8 y,u8 chr,u8 Char_Size)
{
    unsigned char c=0,i=0;
    c=chr-' ';
    if(x>Max_Column-1){x=0;y=y+2;}
    if(Char_Size ==16)
        {
        OLED_Set_Pos(x,y);
        for(i=0;i<8;i++)
        OLED_WR_Byte(F8X16[c*16+i],OLED_DATA);
        OLED_Set_Pos(x,y+1);
        for(i=0;i<8;i++)
        OLED_WR_Byte(F8X16[c*16+i+8],OLED_DATA);
        }
        else {
            OLED_Set_Pos(x,y);
            for(i=0;i<6;i++)
            OLED_WR_Byte(F6x8[c][i],OLED_DATA);
        }
}

u32 oled_pow(u8 m,u8 n)
{
    u32 result=1;
    while(n--)result*=m;
    return result;
}

void OLED_ShowNum(u8 x,u8 y,u32 num,u8 len,u8 size2)
{
    u8 t,temp;
    u8 enshow=0;
    for(t=0;t<len;t++)
    {
        temp=(num/oled_pow(10,len-t-1))%10;
        if(enshow==0&&t<(len-1))
        {
            if(temp==0)
            {
                OLED_ShowChar(x+(size2/2)*t,y,' ',size2);
                continue;
            }else enshow=1;

        }
        OLED_ShowChar(x+(size2/2)*t,y,temp+'0',size2);
    }
}
void OLED_ShowVI(u8 x,u8 y,u32 num,u8 size2)
{
    OLED_ShowNum(x+size2*4-1,y,num%10,1,size2);
    OLED_ShowNum(x+size2*3-1,y,num/10%10,1,size2);
    OLED_ShowNum(x+size2*2-1,y,num/100%10,1,size2);
    OLED_ShowString(x+size2*1-1,y,".",size2);
    OLED_ShowNum(x-1,y,num/1000,1,size2);
}

void OLED_ShowString(u8 x,u8 y,u8 *chr,u8 Char_Size)
{
    unsigned char j=0;
    while (chr[j]!='\0')
    {       OLED_ShowChar(x,y,chr[j],Char_Size);
            x+=8;
        if(x>120){x=0;y+=2;}
            j++;
    }
}

void OLED_Init(void)
{
    P8DIR |= BIT1+BIT2;
    Delay_1ms(200);
    OLED_WR_Byte(0xAE,OLED_CMD);//--display off
    OLED_WR_Byte(0x00,OLED_CMD);//---set low column address
    OLED_WR_Byte(0x10,OLED_CMD);//---set high column address
    OLED_WR_Byte(0x40,OLED_CMD);//--set start line address
    OLED_WR_Byte(0xB0,OLED_CMD);//--set page address

    OLED_WR_Byte(0x81,OLED_CMD); // contract control
    OLED_WR_Byte(0x00,OLED_CMD);//--128

    OLED_WR_Byte(0xA1,OLED_CMD);//set segment remap
    OLED_WR_Byte(0xA6,OLED_CMD);//--normal / reverse
    OLED_WR_Byte(0xA8,OLED_CMD);//--set multiplex ratio(1 to 64)
    OLED_WR_Byte(0x3F,OLED_CMD);//--1/32 duty
    OLED_WR_Byte(0xC8,OLED_CMD);//Com scan direction
    OLED_WR_Byte(0xD3,OLED_CMD);//-set display offset
    OLED_WR_Byte(0x00,OLED_CMD);//

    OLED_WR_Byte(0xD5,OLED_CMD);//set osc division
    OLED_WR_Byte(0x80,OLED_CMD);//

    OLED_WR_Byte(0xD8,OLED_CMD);//set area color mode off
    OLED_WR_Byte(0x05,OLED_CMD);//

    OLED_WR_Byte(0xD9,OLED_CMD);//Set Pre-Charge Period
    OLED_WR_Byte(0xF1,OLED_CMD);//

    OLED_WR_Byte(0xDA,OLED_CMD);//set com pin configuartion
    OLED_WR_Byte(0x12,OLED_CMD);//

    OLED_WR_Byte(0xDB,OLED_CMD);//set Vcomh
    OLED_WR_Byte(0x30,OLED_CMD);//

    OLED_WR_Byte(0x8D,OLED_CMD);//set charge pump enable
    OLED_WR_Byte(0x14,OLED_CMD);//

    OLED_WR_Byte(0xAF,OLED_CMD);//--turn on oled panel
}






volatile unsigned int data[FFT_Dot];


int i=0,d=0;
unsigned int adc_num =0;
bool adc_done=0;
Timer_A_outputPWMParam htim = {0};
char ADC1_OK_V = 0;
char ADC2_OK_I = 0;
volatile unsigned int ADC1_Data_V[SAMP_Dot];
volatile unsigned int ADC2_Data_I[SAMP_Dot];
int count;
bool I_switch = 1;
bool M_switch = 1;
float phase,I_THD;
float temp[FFT_Dot];

//init
void upVcc(void)//核心电压不上升
{
    PMMCTL0_H = 0xA5;                      //开启PMM电源管理，即开锁
    SVSMLCTL |= SVSMLRRL_1 + SVMLE;        //配置SVML电压
    PMMCTL0 = PMMPW + PMMCOREV_3 ;                    //配置内核电压，选择3级
    while((PMMIFG & SVSMLDLYIFG)==0);      //等待配置完成
    PMMIFG &=~ (SVMLVLRIFG + SVMLIFG + SVSMLDLYIFG);
    if((PMMIFG & SVMLIFG)==1)
        while((PMMIFG & SVMLVLRIFG)==0);
    SVSMLCTL &=~ SVMLE;                    //关闭SVML
    PMMCTL0_H = 0x00;                     //锁存配置，即关锁
}
void clock_init(){
    // PMM_setVCore(PMM_CORE_LEVEL_1);
    // GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P5, GPIO_PIN4);   //SMCLK Output
    // GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P5, GPIO_PIN5);   //MCLK Output
    // UCS_turnOnLFXT1(UCS_XT1_DRIVE_3,UCS_XCAP_3);

    // GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P5, GPIO_PIN2);
    // GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P5, GPIO_PIN3);
    // UCS_turnOnXT2 (UCS_XT2_DRIVE_4MHZ_8MHZ);

    // PMM_setVCore(PMM_CORE_LEVEL_3);
    // UCS_initClockSignal(UCS_FLLREF, UCS_XT2CLK_SELECT, UCS_CLOCK_DIVIDER_8);
    // UCS_initFLLSettle(25000, 20);
    // UCS_initClockSignal(UCS_ACLK, UCS_XT1CLK_SELECT, UCS_CLOCK_DIVIDER_1);
    // UCS_initClockSignal(UCS_MCLK, UCS_DCOCLK_SELECT, UCS_CLOCK_DIVIDER_1);
    // UCS_initClockSignal(UCS_SMCLK, UCS_DCOCLK_SELECT, UCS_CLOCK_DIVIDER_1);

    // UCS_setExternalClockSource(32768, 4000000);
     WDTCTL = WDTPW+WDTHOLD;
            P1SEL &= ~BIT1;
            P1DIR |= BIT1;

            P1SEL |= BIT0; //ACLK时钟输入引脚设置
            P1DIR |= BIT0;

            P2SEL |= BIT2; //SMCLK时钟输入引脚设置
            P2DIR |= BIT2;

            P7SEL |= BIT7; //MCLK时钟输入引脚设置
            P7DIR |= BIT7;

            P5SEL |= BIT4|BIT5;//P5.4和P5.5选择XT1晶振功能

            //P5SEL |= BIT2+BIT3;//P5.4和P5.5选择XT2晶振功能（高频震荡源）

            UCSCTL6 |= XCAP_3;
            UCSCTL6 &= ~XT1OFF;//打开 XT1，否则 XT1LFOFFG 可能报错
            upVcc();
            UCSCTL0 = 0; //先清零，FLL 运行时，该寄存器系统会自动配置，不用管
            UCSCTL1 = DCORSEL_6;//通过它来设置DCOCLK的频率范围
            UCSCTL2 = FLLD_1 | 380;//FLLD=1,FLLN=380,则频率为2*（380+1）*32.768K=24.969MHZ
                                   //FLLD_1 2倍频
            __bic_SR_register(SCG0);
            __delay_cycles(782000);

            UCSCTL3 |= SELREF_0;
            do
                {
                   UCSCTL7 &= ~(XT2OFFG + XT1LFOFFG + DCOFFG);
                                            //清除XT2,XT1,DCO故障失效标志位
                   SFRIFG1 &= ~OFIFG;       //清除晶振故障失效中断标志位
                }while(SFRIFG1&OFIFG);      //晶振故障失效中断标志位

            // UCSCTL4 = UCSCTL4&(~(SELS_7|SELM_7))|SELS_3|SELM_3;//为SMCLK、ACLK、MCLK选取信号源
             UCSCTL4 = SELA__XT1CLK + SELM__DCOCLK + SELS__DCOCLK;//SMCLK=MCLK=DCOCLK,ACLK=XT1CLK    
}
bool usart1_init(uint16_t baseAddress, uint32_t Baudrate)
{
    float UART_Temp = 0;
    USCI_A_UART_initParam huart = {0};

    if(baseAddress == USCI_A0_BASE)         //P3.3, P3.4 = USCI_A0 TXD/RXD
    {
        GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P3, GPIO_PIN3);
        GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P3, GPIO_PIN4);
    }
    else if(baseAddress == USCI_A1_BASE)    //P4.4, P4.5 = USCI_A1 TXD/RXD
    {
        GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P4, GPIO_PIN4);
        GPIO_setAsPeripheralModuleFunctionInputPin(GPIO_PORT_P4, GPIO_PIN5);
    }

    if(Baudrate <= 9600)
    {
        huart.selectClockSource = USCI_A_UART_CLOCKSOURCE_ACLK;
        UART_Temp = (float)UCS_getACLK()/Baudrate;
    }
    else
    {
        huart.selectClockSource = USCI_A_UART_CLOCKSOURCE_SMCLK;
        UART_Temp = (float)UCS_getSMCLK()/Baudrate;
    }

    if(UART_Temp < 16)
        huart.overSampling = USCI_A_UART_LOW_FREQUENCY_BAUDRATE_GENERATION;
    else
    {
        huart.overSampling = USCI_A_UART_OVERSAMPLING_BAUDRATE_GENERATION;
        UART_Temp /= 16;
    }

    huart.clockPrescalar = (int)UART_Temp;

    if(huart.overSampling == USCI_A_UART_LOW_FREQUENCY_BAUDRATE_GENERATION)
    {
        huart.secondModReg = (int)((UART_Temp - huart.clockPrescalar) * 8);
    }
    else
    {
        huart.firstModReg = (int)((UART_Temp - huart.clockPrescalar) * 16);
    }

    huart.parity = USCI_A_UART_NO_PARITY;
    huart.msborLsbFirst = USCI_A_UART_LSB_FIRST;
    huart.numberofStopBits = USCI_A_UART_ONE_STOP_BIT;
    huart.uartMode = USCI_A_UART_MODE;

    if (STATUS_FAIL == USCI_A_UART_init(baseAddress, &huart))
    {
        return STATUS_FAIL;
    }

    //Enable UART module for operation
    USCI_A_UART_enable(baseAddress);

    //Enable Receive Interrupt
    USCI_A_UART_clearInterrupt(baseAddress, USCI_A_UART_RECEIVE_INTERRUPT);
    USCI_A_UART_enableInterrupt(baseAddress, USCI_A_UART_RECEIVE_INTERRUPT);

    return STATUS_SUCCESS;
}
void UART_printf(uint16_t baseAddress, const char *format,...)
{
    uint32_t length;
    va_list args;
    uint32_t i;
    char TxBuffer[128] = {0};

    va_start(args, format);
    length = vsnprintf((char*)TxBuffer, sizeof(TxBuffer), (char*)format, args);
    va_end(args);

    for(i = 0; i < length; i++)
        USCI_A_UART_transmitData(baseAddress, TxBuffer[i]);
}
void adc_init()
{
    P6SEL |= BIT0+BIT1;                             // Enable A/D channel inputs
    ADC12CTL0 = ADC12ON+ADC12SHT0_8+ADC12MSC+ADC12REFON; // // 开启ADC12 + 多通道采样 + adc样本保持：8位
    ADC12CTL1 = ADC12CONSEQ_3 + ADC12SHS_1;       // Use sampling timer, repeated sequence
    ADC12MCTL0 = ADC12INCH_0;                 // ref+=AVcc, channel = A0
    ADC12MCTL1 = ADC12INCH_1+ADC12EOS;                 // ref+=AVcc, channel = A1
//     ADC12IE = 0x02;                           // Enable ADC12IFG.3
    ADC12CTL0 |= ADC12ENC;                    //使能所有其他寄存器的更改配置操作都要在这一位为0时配置
    // Setup DMA COMMON
    DMACTL0 = DMA0TSEL_24 + DMA1TSEL_24;      // ADC的DMA通道
    DMACTL4 = DMARMWDIS;                      // 读写CPU的时候禁止DMA传输
    // Setup DMA0
    DMA0CTL &= ~DMAIFG;
    DMA0CTL = DMADT_4+DMAEN+DMADSTINCR_3 + DMAIE;    // DMA重复单次采集+ DMA使能 +目标地址增量 +  DMA中断使能
    DMA0SZ = SAMP_Dot;        // DMA0 size = 100
    __data20_write_long((uintptr_t) &DMA0SA,(uintptr_t) &ADC12MEM0); //DMA0SA ：DMA 通道0的源地址 ADC12MEM0 ：DC12 Conversion Memory 0
    __data20_write_long((uintptr_t) &DMA0DA,(uintptr_t) &ADC1_Data_V[0]);
    // Setup DMA1
    DMA1CTL &= ~DMAIFG;
    DMA1CTL = DMADT_4+DMAEN+DMADSTINCR_3 + DMAIE; // Rpt single tranfer, Destination address is incremented.
    DMA1SZ = SAMP_Dot;       // DMA0 size = 100
    __data20_write_long((uintptr_t) &DMA1SA,(uintptr_t) &ADC12MEM1); // Source block address
    __data20_write_long((uintptr_t) &DMA1DA,(uintptr_t) &ADC2_Data_I[0]);
    //interrupts enabled
    __bis_SR_register(GIE);
}
void Timer_A_PWM_Init(void)
{  
    Timer_A_outputPWMParam htim = {0};
    //P1.2复用输出
//    GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P1, GPIO_PIN2);
    //时钟源选为SMCLK = 25MHz
    htim.clockSource = TIMER_A_CLOCKSOURCE_SMCLK;
    //分频系数设为10
    htim.clockSourceDivider = TIMER_A_CLOCKSOURCE_DIVIDER_10;
    //装载值设为250 - 1
    htim.timerPeriod = TIMER_PERIOD - 1;
    //P1.2 对应 TA0.1 故设为TIMER_A_CAPTURECOMPARE_REGISTER_1
    htim.compareRegister = TIMER_A_CAPTURECOMPARE_REGISTER_1;
    htim.compareOutputMode = TIMER_A_OUTPUTMODE_RESET_SET  ;
    //初始比较值为装载值的一半 即初始占空比为50%
    htim.dutyCycle = TIMER_PERIOD / 2;
    //P1.2 对应 TA0.1 为TIMER_A0_BASE
    Timer_A_outputPWM(TIMER_A0_BASE, &htim);

}
void Timer_A_PWM_Stop(void)
{
    Timer_A_outputPWMParam htim = {0};
    //P1.2复用输出
//    GPIO_setAsPeripheralModuleFunctionOutputPin(GPIO_PORT_P1, GPIO_PIN2);
    //时钟源选为SMCLK = 25MHz
    htim.clockSource = TIMER_A_CLOCKSOURCE_SMCLK;
    //分频系数设为40
    htim.clockSourceDivider = TIMER_A_CLOCKSOURCE_DIVIDER_20;
    //装载值设为250 - 1
    htim.timerPeriod = 0;
    //P1.2 对应 TA0.1 故设为TIMER_A_CAPTURECOMPARE_REGISTER_1
    htim.compareRegister = TIMER_A_CAPTURECOMPARE_REGISTER_1;
    htim.compareOutputMode = OUTMOD_7  ;
    //初始比较值为装载值的一半 即初始占空比为50%
    htim.dutyCycle = 0;
    //P1.2 对应 TA0.1 为TIMER_A0_BASE
    Timer_A_outputPWM(TIMER_A0_BASE, &htim);
}
void USART1_Config(void)
{
    //串口初始化
     P4SEL    |=  BIT4+BIT5 ;                    // P54.4,5 = USCI_A1 TXD/RXD
     UCA1CTL1 |=  UCSWRST;                      // **Put state machine in reset**
     UCA1CTL1 |=  UCSSEL_1;                     // ACLK
     UCA1BR0   =  0x03;                         // 32768Hz 9600 波特率为9600
     UCA1BR1   =  0x00;                         // 32768Hz 9600
     UCA1MCTL |=  UCBRS_3 + UCBRF_0;           // Modulation UCBRSx=1, UCBRFx=0
     UCA1CTL1 &= ~UCSWRST;                   // **Initialize USCI state machine**
     UCA1IE   |=  UCRXIE;                       // Enable USCI_A1 RX interrupt 使能中断
}
void key_init()
{
    P2DIR&=~BIT1;//输入方向
    P1DIR&=~BIT1;
    P2IFG&=~BIT1;//清除中断标志
    P1IFG&=~BIT1;
    P2IE|=BIT1;//开启中断
    P1IE|=BIT1;
    P2IES|=BIT1;//下降沿触发
    P1IES|=BIT1;
    P1IFG &=~BIT1;//清空中断标志
    P2IN=BIT1;//输入拉高
    P1IN=BIT1;
    P2OUT|=BIT1;
    P1OUT|=BIT1;
	P2REN =BIT1;P1REN =BIT1;//上拉电阻

    _BIS_SR(GIE);//开启中断使能
    __bis_SR_register(GIE);
    __enable_interrupt(); //开总中断
}

// 校正函数
float correct_power_factor(float measured_pf) {

    float angle_offset_degrees=5.0;
    // 将功率因素转换为弧度
    float theta = acos(measured_pf);
    
    // 将角度偏转值从度转换为弧度
    float angle_offset_radians = angle_offset_degrees * (PI / 180.0);
    
    // 计算新的相位角
    float theta_new = theta + angle_offset_radians;
    
    // 计算新的功率因素
    float new_pf = cos(theta_new);
    
    return new_pf;
}



void rms(){

    float V_DC_component = 0.0;
    float V_AC_component[SAMP_Dot];
    float V_sum_squares = 0.0;
    float V_rms;

    float I_DC_component = 0.0;
    float I_AC_component[SAMP_Dot];
    float I_sum_squares = 0.0;
    float I_rms,I_rms_o;

    float P_sum = 0.0;
    float P_avg;
    float power_factor;

    int i;
    // 计算电压的直流分量
    for (i = 0; i < SAMP_Dot; i++) {
        V_DC_component += ADC1_Data_V[i];
    }
    V_DC_component /= SAMP_Dot;

    V_DC_component = 2048.0;

    // 去除直流分量并计算交流分量的平方和
    for (i = 0; i < SAMP_Dot; i++) {
        V_AC_component[i] = ADC1_Data_V[i] - V_DC_component;
        V_sum_squares += V_AC_component[i] * V_AC_component[i];
//        UART_printf(USCI_A1_BASE, "ADC1: %d  \r\n",ADC1_Data_V[i]);
    }

    // 计算交流电压的有效值
    V_rms =  0.5621*sqrt(V_sum_squares / SAMP_Dot)-1.0515;


    // 打印电压结果

    // 计算电流的直流分量
    for (i = 0; i < SAMP_Dot; i++) {
        I_DC_component += ADC2_Data_I[i];
    }
    I_DC_component /= SAMP_Dot;

//    I_DC_component = 2048.0;

    // 去除直流分量并计算交流分量的平方和
    for (i = 0; i < SAMP_Dot; i++) {
        I_AC_component[i] = ADC2_Data_I[i] - I_DC_component;
        I_sum_squares += I_AC_component[i] * I_AC_component[i];
//        UART_printf(USCI_A1_BASE, "ADC2: %d  \r\n",ADC2_Data_I[i]);
    }

    // 计算交流电流的有效值
    if(I_switch){
//    if(0){
        I_rms = 0.0081*sqrt(I_sum_squares / SAMP_Dot)-0.024;
        // 计算有功功率
         for (i = 0; i < SAMP_Dot; i++) {
             P_sum += (0.5621*(ADC1_Data_V[i] - V_DC_component)-1.0515) * (0.0081*(ADC2_Data_I[i] - I_DC_component)-0.024);
         }
         P_avg = 0.99*(P_sum / SAMP_Dot)-1.3101;
    }
    else{
        I_rms = 0.9478*(0.0015*sqrt(I_sum_squares / SAMP_Dot)-0.029)+0.0358;
        // 计算有功功率
         for (i = 0; i < SAMP_Dot; i++) {
             P_sum += (0.5621*(ADC1_Data_V[i] - V_DC_component)-1.0515) * (0.9478*(0.0015*(ADC2_Data_I[i] - I_DC_component)-0.029)+0.0358);
         }
         P_avg =(P_sum / SAMP_Dot);
    }


//    // 计算有功功率
//     for (i = 0; i < SAMP_Dot; i++) {
//         P_sum += (0.5621*(ADC1_Data_V[i] - V_DC_component)-1.0515) * (0.0081*(ADC2_Data_I[i] - I_DC_component)-0.024);
//     }
//     P_avg = 0.99*(P_sum / SAMP_Dot)-1.3101;

    // 计算功率因数
    power_factor = correct_power_factor( P_avg / (V_rms * I_rms));
    power_factor =  P_avg / (V_rms * I_rms);



    UART_printf(USCI_A1_BASE, "V_RMS: %f  ",V_rms);
    // 打印电流结果
    UART_printf(USCI_A1_BASE, "I_RMS: %f ", I_rms);
    // 打印有功功率和功率因数
    UART_printf(USCI_A1_BASE, "P: %f W, PF: %f \n", P_avg, power_factor);




    char temp_show[50]={0};
    sprintf(&temp_show,"V :%011.6f",V_rms);
    OLED_ShowString(0, 0 , temp_show, 16);
    if(I_switch)
    sprintf(&temp_show,"IS:   %.6f",I_rms);
    else
    sprintf(&temp_show,"IL:   %.6f",I_rms);
    OLED_ShowString(0, 2, temp_show, 16);
    sprintf(&temp_show,"P :%011.6f",P_avg);
    OLED_ShowString(0, 4, temp_show, 16);
    sprintf(&temp_show,"PF:   %.6f",power_factor);
    OLED_ShowString(0, 6, temp_show, 16);


}

bool first_dft=1;
//DFT
void DFT(){
    float re[FFT_Dot],im[FFT_Dot],ADC1_Vref[FFT_Dot],ADC2_Iref[FFT_Dot];
    float pharse_V[FFT_Dot],pharse_I[FFT_Dot];
    float r,i;
    int k=0,n=0;
    int count;
    int fft_dot;
    float sum=0;
    float I_VAL;



if (first_dft)
{
    OLED_Init();
    OLED_Clear();
            OLED_ShowString(0, count , "TESTING", 16);
            OLED_ShowString(0, 2 , "THD", 16);
            first_dft=0;
}


    for(k = 0;k < FFT_Dot;k++)
        {
            r = 0;
            i = 0;
            for( n=0;n < FFT_Dot;n++)
            {
                r += cosf(2*PI/FFT_Dot*k*n) *ADC2_Data_I[n] * 3.3 / 4096;
                i -= sinf(2*PI/FFT_Dot*k*n) *ADC2_Data_I[n] * 3.3 / 4096;//欧拉公式
            }
                re[k] = r;
                im[k] = i;
                ADC2_Iref[k]= sqrtf(r*r+ i*i);
        }
    ADC2_Iref[0]/=FFT_Dot; //直流分量



    for (count = 0 ;count < FFT_Dot /2; count ++)
    {

        ADC2_Iref[count]/=(FFT_Dot/2);
//             UART_printf(USCI_A1_BASE,"%f\r\n",ADC2_Iref[count]);
    }

    OLED_Init();
    OLED_Clear();

    //电流谐波系数
    for(count=2,I_THD=0;count<25;count++){
        I_THD+=ADC2_Iref[count]*ADC2_Iref[count];
//        UART_printf(USCI_A1_BASE,"I_THD%d : %f  ",count,ADC2_Iref[count]);
    }
    I_THD=sqrtf(I_THD)/ADC2_Iref[1]*1.05;
    UART_printf(USCI_A1_BASE,"I_THD : %f  \r\n\r\n",I_THD);

    char temp_show[50]={0};
    sprintf(&temp_show,"I_THD:%.6f",I_THD);
    OLED_ShowString(0, 0 , temp_show, 16);




    for(count=2;count<8;count++){

            sprintf(&temp_show,"%d:%.3f",count,ADC2_Iref[count]);
            OLED_ShowString(0, count , temp_show, 8);
        }
    for(count=8;count<14;count++){

            sprintf(&temp_show,"%d:%.3f",count,ADC2_Iref[count]);
            OLED_ShowString(64, count-6 , temp_show, 8);
        }


        
}





/**
 * main.c
 */

int main(void)
{
    //init
    WDT_A_hold(WDT_A_BASE);
    clock_init();
    USART1_Config();
    Timer_A_PWM_Init();
    adc_init();
    key_init();
    REFCTL0 |= REFMSTR + REFON + REFVSEL_3;

    OLED_Init();
    OLED_Clear();
    OLED_ShowString(0,0,"Booting...",16);
    
    while(1){
        if(ADC1_OK_V&ADC2_OK_I)//ADC1跟ADC2均采集完毕
        {   
        ADC1_OK_V = 0;
        ADC2_OK_I = 0;
        Timer_A_PWM_Stop();




        if (M_switch) {
        rms();
        first_dft=1;
        }else {
        DFT();
        }


        Timer_A_PWM_Init();
        }
    }
}

#if defined(__TI_COMPILER_VERSION__) || defined(__IAR_SYSTEMS_ICC__)
#pragma vector=DMA_VECTOR
__interrupt void DMA_ISR(void)
#elif defined(__GNUC__)
void __attribute__ ((interrupt(DMA_VECTOR))) DMA_ISR (void)
#else
#error Compiler not supported!
#endif
{
  switch(__even_in_range(DMAIV,16))
  {
    case 0:  ;break;
    case 2: ADC1_OK_V = 1 ; break;          // DMA0IFG = DMA Channel 0
    case 4: ADC2_OK_I = 1 ; break;          // DMA1IFG = DMA Channel 1
    case 6: break;                          // DMA2IFG = DMA Channel 2
    case 8: break;                          // DMA3IFG = DMA Channel 3
    case 10: break;                         // DMA4IFG = DMA Channel 4
    case 12: break;                         // DMA5IFG = DMA Channel 5
    case 14: break;                         // DMA6IFG = DMA Channel 6
    case 16: break;                         // DMA7IFG = DMA Channel 7
    default: break;
  }
}
#pragma vector = PORT1_VECTOR    //S1中断服务函数
__interrupt void P1_ISR()
{
	if(P1IFG & BIT1)
	{
		while((P1IN & BIT1)==0);
		I_switch = !I_switch;
	    OLED_Init();
	    OLED_Clear();
        if(I_switch)
            UART_printf(USCI_A1_BASE,"I change to 1\r\n");
        else
            UART_printf(USCI_A1_BASE,"I change to 2\r\n");
	}
	P1IFG &=~ BIT1;
}
#pragma vector = PORT2_VECTOR    //S1中断服务函数
__interrupt void P2_ISR()
{
	if(P2IFG & BIT1)
	{
		while((P2IN & BIT1)==0);
        M_switch = !M_switch;
        OLED_Clear();
        if(M_switch)
            UART_printf(USCI_A1_BASE,"M change to 1 \n");
        else
            UART_printf(USCI_A1_BASE,"M change to 2 \n");
	}
	P2IFG &=~ BIT1;
}
